{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/fluidity.js","webpack:///./lib/rendering/render_main.js","webpack:///./lib/structures/capsule.js","webpack:///./lib/structures/particle.js","webpack:///./lib/structures/spatialhash.js","webpack:///./lib/util/scaling_consts.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmD;AACN;AACA;AACM;AACN;;AAE7C;AACA,uBAAuB,+DAAW;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,4DAAQ;AACnC,2BAA2B,4DAAQ;AACnC,2BAA2B,4DAAQ;AACnC,2BAA2B,4DAAQ;AACnC,2BAA2B,4DAAQ;AACnC;AACA;AACA,0BAA0B,2DAAO,EAAE,kEAAuB,KAAK,kEAAuB,YAAY,kEAAuB,KAAK,kEAAuB,gBAAgB,0BAA0B;AAC/L,uKAAuK,8BAA8B;AACrM,0BAA0B,2DAAO,EAAE,kEAAuB,KAAK,kEAAuB,YAAY,kEAAuB,KAAK,kEAAuB,gBAAgB,8BAA8B;AACnM,0BAA0B,2DAAO,8BAA8B,8BAA8B,E;AAC7F,wBAAwB,8DAAM;;;;AAI9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA,CAAC,E;;;;;;;;;;;;ACzDD;AAAA;AAAA;AACoD;;AAEpD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,+D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEe,qEAAM,E;;;;;;;;;;;;ACvCrB;AAAA;AAAA;AAAA;AAAoD;AACpD;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACxDA;AAAA,WAAW,YAAY;;;AAGvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEe,uEAAQ,E;;;;;;;;;;;;ACfvB;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,qBAAqB,gBAAgB;AACrC,yBAAyB,gBAAgB;AACzC;AACA;AACA;;;;AAIA;AACA,iCAAiC,gCAAgC;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEe,0EAAW,E;;;;;;;;;;;;;;;;;ACxH1B;AACO;AACA;;;AAGA,aAAa,kB","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/fluidity.js\");\n","import SpatialHash from './structures/spatialhash';\nimport particle from './structures/particle';\nimport {Capsule} from './structures/capsule';\nimport * as constants from './util/scaling_consts';\nimport Render from './rendering/render_main';\n\ndocument.addEventListener('DOMContentLoaded', () =>{\n    const space =  new SpatialHash(5, [2,2], [40,40])\n\n    const canvas = document.getElementById('fluidCanvas');\n    const context = canvas.getContext('2d');\n\n    context.fillStyle = 'rgb(0, 0, 0)';\n    context.fillRect(0, 0, 1100, 750);\n\n    window.context = context;\n    window.space = space\n    window.particle1 = new particle([10, 10], [1, 1], \"red\");\n    window.particle2 = new particle([10, 15], [1, 1], \"red\");\n    window.particle3 = new particle([2, 35], [1, 1], \"red\");\n    window.particle4 = new particle([2, 30], [1, 1], \"red\");\n    window.particle5 = new particle([5, 35], [1, 1], \"red\");\n    window.vector1 = new p5.Vector(1, 2);\n    window.vector2 = new p5.Vector(9, 10);\n    window.capsule1 = new Capsule([constants.CONTAINER_MIN[0], constants.CONTAINER_MIN[1] + 30], [constants.CONTAINER_MAX[0], constants.CONTAINER_MIN[1] + 30], 15, {'r':255, 'g':255, 'b': 51})\n    // window.capsule = new Capsule([constants.CONTAINER_MIN[0], constants.CONTAINER_MIN[1] + 15], [constants.CONTAINER_MIN[0], constants.CONTAINER_MAX[1] + 15], 15, { 'r': 255, 'g': 255, 'b': 51 })    \n    window.capsule2 = new Capsule([constants.CONTAINER_MIN[0], constants.CONTAINER_MAX[1] - 15], [constants.CONTAINER_MAX[0], constants.CONTAINER_MAX[1] - 15], 15, { 'r': 255, 'g': 255, 'b': 51 })   \n    window.capsule3 = new Capsule([400, 500], [600, 700], 15, { 'r': 255, 'g': 255, 'b': 51 });       \n    window.render = new Render(context, canvas.width, canvas.height);\n\n \n    \n    //how to draw semicircle of a capsule\n    // context.beginPath();\n    // context.fillStyle = 'rgb(255,255,51)';\n    // context.arc(500, 500, 15, 1.5* Math.PI, 0.5*Math.PI);\n    // context.fillRect(400,485, 100, 30);\n    // context.arc(400, 500, 15, 0.5 * Math.PI, 1.5 * Math.PI);\n    // context.fill();\n    // context.closePath();\n\n    var imageObj = new Image();\n    imageObj.onload = function () {\n        var pattern = context.createPattern(imageObj, \"repeat\");\n\n        context.beginPath(); // begin custom shape\n        // arc(400, 400, 50\n        context.fillRect(400,400,100,100);\n        context.closePath(); // complete custom shape\n\n        context.fillStyle = pattern;\n        context.fill();\n\n    };\n    imageObj.src = \"lib/util/assets/particle_no_border.png\";\n\n    // https://github.com/lukix/fluid-simulation\n});","// import particleImage from '../util/images/particle_no_border.png'\nimport * as constants from '../util/scaling_consts';\n\nclass Render {\n    constructor(context, canvasWidth, canvasHeight){\n     this.context = context;\n     this.canvasWidth = canvasWidth;\n     this.canvasHeight = canvasHeight;\n    }\n\n    draw(){\n\n    }\n\n    _drawCapsule(capsule){\n            let startPoint = capsule.pA;\n            let endPoint = capsule.pB;\n            let lineSegmentLength = endPoint.dist(startPoint) ; \n            \n            debugger\n            //for now just draw the frame, will later update for allowing users to draw capsules\n            //top\n            this.context.beginPath();\n            this.context.fillStyle = 'rgb(255,255,51)';\n            this.context.arc(endPoint['x'], endPoint['y'] - capsule.radius, capsule.radius, 1.5 * Math.PI, 0.5 * Math.PI);\n            this.context.fillRect(startPoint['x'], startPoint['y'] - capsule.radius, lineSegmentLength , 30);\n            this.context.arc(startPoint['x'], startPoint['y'] - capsule.radius, capsule.radius, 0.5 * Math.PI, 1.5 * Math.PI);\n            this.context.fill();\n            this.context.closePath();\n\n            \n    }\n\n    _drawParticle(){\n\n    }\n\n}\n\nexport default Render;","import * as constants from '../util/scaling_consts';\n//Create our capsule data type which tightly bounds the particle in a combination of sphere and cylinder \n//primitives. We use the capsule data structure because it makes collision detection easier with more complex systems\n//since there is always a line with a surrounding radius to reference, and we just have to compare the sum of the radii of both object-capsules \n//in question. \n//Reference: http://image.diku.dk/projects/media/kelager.06.pdf#page=33\n\nexport const Capsule = function(pointA, pointB, radius, color) {\n    this.pA = new p5.Vector(pointA[0], pointA[1]);\n    this.pB = new p5.Vector(pointB[0], pointB[1]);\n\n    this.radius = radius;\n    this.color = color;\n\n};\n\n//Now we create a depth-checker function, also the implicit function of the capsule, which will\n//determine whether we have a collision with another capsule\n//Relative to a collision-point cp, the function will return a negative number if there is penetration, \n//a positive number if there is not, and 0 if the surfaces are touching flush.\n//Reference: http://image.diku.dk/projects/media/kelager.06.pdf#page=33 eq 4.46\n\nexport const capsuleImplicit = function(capsule, x) {\n\n        const pA = capsule.pA;\n        const pB = capsule.pB;\n        const r = capsule.radius;\n\n        //Check to see if pA needs to be negated due to origin subtraction\n        //We now have a vector which represents the line connecting points A and B in our capsule\n        const capsuleLine = p5.Vector.sub(pB, pA);\n\n        //Now we will do some algebraic manipulation to ultimately find the parameter t in the parametric equation from\n        //Reference: http://image.diku.dk/projects/media/kelager.06.pdf#page=33 eq 4.42\n        //First we find the distance between point A and the collision point cp\n        const collisionDiffVector = p5.Vector.sub(pA, x);\n\n        //Now we solve for t using the equation 4.43 where we project the collision difference vector (pA - x)\n        // onto the capsule internal line segment (pA - pB) and divide this over the absolute sqaure magnitude of the aformentioned\n        //segment.\n        let t = (-1 * p5.Vector.dot(collisionDiffVector, capsuleLine)) / capsuleLine.magSq();\n\n\n        //Create clamp function to cap the value of the variable t to a range of [0,1]\n        function clamp(num, min, max) {\n            return num <= min ? min : num >= max ? max : num;\n        }\n\n        t = clamp(t,0,1);\n\n        //Having solved for t, we can go back to equation 4.42 and solve for l(t)=q, which is the location of the point\n        //on the capsule line segment we are interested in with relation to the collision.\n        const q = p5.Vector.add(pA,capsuleLine.mult(t));\n\n        //Referencing the original equation 4.40, we solve for and return the implicit function F_capsule. \n        return p5.Vector.mag(q.sub(x)) - r ;\n};\n\n\n\n","// import { constants } from \"../util/scaling_consts\";\n\n\nfunction Particle (pos, vel, color) {\n    this.position = pos;\n    this.velocity = new p5.Vector(vel[0], vel[1]);\n\n    this.color = color;\n    this.radius = 0.05;\n\n    this.density = 0;\n    this.nearDensity = 0;\n\n}\n\nexport default Particle;","//Here we create a spatial hash data structure class to be able to find the nearest neighboring particles of a particular particle.\n//We create a grid system of cells so that our particle in question resides in a cell. We then check how many particles are located \n//within that same cell. We space the cells based on a support radius s, which is the maximum radius of influence for a particle.\n//Basically, the particle has some sort of influence to other particles since it has a finite radius and is not an actual point with 0\n//dimension. Thus, the influence, on a scale of 0 to 1, would be 0 at the radius, and progressively increases to 1 the closer oen gets to the center. \n// Implementing a hash-map allows us to do this in O(1) time instead of O(n) if we used  an array as a data structure.\n\n\n//We begin by setting up our grid, which has a bottom-left min coordinate and a top-right vertex grid-coordinate max. Using these two\n//points we can construct the cells within this grid. \nclass SpatialHash {\n    constructor(s, gridMin, gridMax ){\n        this.s = s;\n        this.min = gridMin;\n        this.max = gridMax;\n\n        //Compute dimensions of a single cell\n        this.cellX = Math.round((this.max[0] - this.min[0]) / this.s);\n        this.cellY = Math.round((this.max[1] - this.min[1]) / this.s);\n\n        //Initialize grid and the spatial hash\n        this.grid = [];\n        this.spatialHash = {};\n\n        this._gridPos = this._gridPos.bind(this);\n        this._gridIndex = this._gridIndex.bind(this);\n        this.populateGrid = this.populateGrid.bind(this);\n        this.findNearestNeighbors = this.findNearestNeighbors.bind(this);\n    }\n\n    // We create a helper function which will take a coordinate from the canavs system and apply it to our grid mesh.\n    // We subtract relative to the min coordinate as this is a natural way \n    // to read postions in a grid and will give a more intuitive position coordinate. For example, the coordinate [9,19] in a \n    //20*20 canvas with the min at the origin would give us a position of [0,1].\n    _gridPos(position){\n        return [\n            Math.floor((position[0] - this.min[0]) / this.s),\n            Math.floor((position[1] - this.min[1]) / this.s)\n        ]\n    }\n\n    //Convert grid position e.g (grid[0,1]) to index of cells (grid[1])\n    _gridIndex(gridPos){\n        return gridPos[1] * this.cellX + gridPos[0];\n    }\n\n    populateGrid(particles){\n\n        //initialize grid matrix (nest the grid)\n        for (let i=0; i < this.cellX * this.cellY; ++i){\n            this.grid[i] = [];\n        }\n\n        //populate the spatial hash with all our cells and make their values arrays so we can push into them later\n        for (let j=0; j < this.cellX; ++j) {\n            for (let k=0; k < this.cellY; ++k){\n                this.spatialHash[[j,k]] = []\n            }\n        }\n        \n        \n\n        //populate the grid with particles\n        for (let ithParticle = 0; ithParticle < particles.length; ++ithParticle){\n            //first grab the particle from the particles array\n            let currentParticle = particles[ithParticle];\n\n            //now create the postion of the particle on the grid based off of the particles position\n            let particleOnGrid = this._gridPos(currentParticle.position);\n            \n            //push this particle into the grid array using our converter function to convert grid position to index\n            this.grid[this._gridIndex(particleOnGrid)].push(currentParticle);\n\n            //Now we want to set the position key in our spatial hash\n            this.spatialHash[particleOnGrid].push(currentParticle)\n        }\n\n\n    }\n\n    //find particles that are within the bounding box whose dimensions are bound by the support radius of the particle\n    findNearestNeighbors(particle){\n        //first we get the bounding box boundaries\n        const boundingBoxMins = this._gridPos([particle.position[0] - this.s, particle.position[1] - this.s]);\n        const boundingBoxMaxs = this._gridPos([particle.position[0] + this.s, particle.position[1] + this.s]);\n\n        //introduce the clamp function again to filter bounding box range to be inside our grid if on the outside\n        function clamp(num, min, max) {\n            return num <= min ? min : num >= max ? max : num;\n        }\n\n        const bbXmax = clamp(boundingBoxMaxs[0], 0, this.cellY-1);\n        const bbXmin = clamp(boundingBoxMins[0], 0, this.cellY-1);\n        const bbYmin = clamp(boundingBoxMins[1], 0, this.cellY-1);\n        const bbYmax = clamp(boundingBoxMaxs[1], 0, this.cellY-1);\n\n        //this will be the array that will store our neighbors within the support radius\n        let neighbors = [];\n\n        const cells = Object.keys(this.spatialHash);\n\n        //check to see if cell is within the bounds of the bounding box, and if it is then \n        //concat the values into the array\n        cells.forEach((cell) => {\n            if ((parseInt(cell[0]) >= bbXmin && parseInt(cell[0]) <= bbXmax) && (parseInt(cell[2]) >= bbYmin && parseInt(cell[2]) <= bbYmax)){\n                neighbors = neighbors.concat(this.spatialHash[cell])\n            }\n        })\n\n        //use this function to filter out particle we are finding neighbors for, since we added it to our neighbors array\n        function particleFilter(value){\n            return value.position !== particle.position\n        }\n\n        //return the nearest neighbors\n        return neighbors.filter(particleFilter);\n        \n    }\n\n}\n\nexport default SpatialHash;","\n// this is the min and max points of the simulation world.\nexport const CONTAINER_MIN = [0, 0];\nexport const CONTAINER_MAX = [1100, 750];\n\n\nexport const h = 10; // support radius"],"sourceRoot":""}