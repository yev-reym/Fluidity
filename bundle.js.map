{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/fluidity.js","webpack:///./lib/rendering/render.js","webpack:///./lib/structures/particle.js","webpack:///./lib/structures/spatialhash.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAmD;AACN;AACE;;AAE/C;AACA,uBAAuB,+DAAW;;AAElC;AACA,2BAA2B,4DAAQ;AACnC,2BAA2B,4DAAQ;AACnC,2BAA2B,4DAAQ;AACnC,2BAA2B,4DAAQ;AACnC,2BAA2B,4DAAQ;AACnC,yBAAyB,6DAAW;;;AAGpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC,E;;;;;;;;;;;;;;;AC1BM,8E;;;;;;;;;;;;;;;ACCP;AACA;AACA;;AAEA;;AAEA;;AAEe,uEAAQ,E;;;;;;;;;;;;ACVvB;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,qBAAqB,gBAAgB;AACrC,yBAAyB,gBAAgB;AACzC;AACA;AACA;;;;AAIA;AACA,iCAAiC,gCAAgC;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEe,0EAAW,E","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/fluidity.js\");\n","import SpatialHash from './structures/spatialhash';\nimport particle from './structures/particle';\nimport {particleImg} from './rendering/render';\n\ndocument.addEventListener('DOMContentLoaded', () =>{\n    const space =  new SpatialHash(5, [2,2], [40,40])\n   \n    window.space = space\n    window.particle1 = new particle([10, 10], [1, 1], \"red\");\n    window.particle2 = new particle([10, 15], [1, 1], \"red\");\n    window.particle3 = new particle([2, 35], [1, 1], \"red\");\n    window.particle4 = new particle([2, 30], [1, 1], \"red\");\n    window.particle5 = new particle([5, 35], [1, 1], \"red\");\n    window.particleImg = particleImg;\n\n\n    const canvas = document.getElementById('fluidCanvas');\n    const canvasGL = canvas.getContext('webgl');\n\n    if (canvasGL === null) {\n        alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n        return;\n    }\n\n    canvasGL.clearColor(0.0, 0.0, 0.0, 1.0);\n    canvasGL.clear(canvasGL.COLOR_BUFFER_BIT);\n\n});","\nexport const particleImg = new p5.Textures.loadimage('images/particle_no_border.png')","\n\nfunction particle (pos, vel, color) {\n    this.position = pos;\n    this.velocity = new p5.Vector(vel[0], vel[1]);\n\n    this.color = color;\n\n}\n\nexport default particle;","//Here we create a spatial hash data structure class to be able to find the nearest neighboring particles of a particular particle.\n//We create a grid system of cells so that our particle in question resides in a cell. We then check how many particles are located \n//within that same cell. We space the cells based on a support radius s, which is the maximum radius of influence for a particle.\n//Basically, the particle has some sort of influence to other particles since it has a finite radius and is not an actual point with 0\n//dimension. Thus, the influence, on a scale of 0 to 1, would be 0 at the radius, and progressively increases to 1 the closer oen gets to the center. \n// Implementing a hash-map allows us to do this in O(1) time instead of O(n) if we used  an array as a data structure.\n\n\n//We begin by setting up our grid, which has a bottom-left min coordinate and a top-right vertex grid-coordinate max. Using these two\n//points we can construct the cells within this grid. \nclass SpatialHash {\n    constructor(s, gridMin, gridMax ){\n        this.s = s;\n        this.min = gridMin;\n        this.max = gridMax;\n\n        //Compute dimensions of a single cell\n        this.cellX = Math.round((this.max[0] - this.min[0]) / this.s);\n        this.cellY = Math.round((this.max[1] - this.min[1]) / this.s);\n\n        //Initialize grid and the spatial hash\n        this.grid = [];\n        this.spatialHash = {};\n\n        this._gridPos = this._gridPos.bind(this);\n        this._gridIndex = this._gridIndex.bind(this);\n        this.populateGrid = this.populateGrid.bind(this);\n        this.findNearestNeighbors = this.findNearestNeighbors.bind(this);\n    }\n\n    // We create a helper function which will take a coordinate from the canavs system and apply it to our grid mesh.\n    // We subtract relative to the min coordinate as this is a natural way \n    // to read postions in a grid and will give a more intuitive position coordinate. For example, the coordinate [9,19] in a \n    //20*20 canvas with the min at the origin would give us a position of [0,1].\n    _gridPos(position){\n        return [\n            Math.floor((position[0] - this.min[0]) / this.s),\n            Math.floor((position[1] - this.min[1]) / this.s)\n        ]\n    }\n\n    //Convert grid position e.g (grid[0,1]) to index of cells (grid[1])\n    _gridIndex(gridPos){\n        return gridPos[1] * this.cellX + gridPos[0];\n    }\n\n    populateGrid(particles){\n\n        //initialize grid matrix (nest the grid)\n        for (let i=0; i < this.cellX * this.cellY; ++i){\n            this.grid[i] = [];\n        }\n\n        //populate the spatial hash with all our cells and make their values arrays so we can push into them later\n        for (let j=0; j < this.cellX; ++j) {\n            for (let k=0; k < this.cellY; ++k){\n                this.spatialHash[[j,k]] = []\n            }\n        }\n        \n        \n\n        //populate the grid with particles\n        for (let ithParticle = 0; ithParticle < particles.length; ++ithParticle){\n            //first grab the particle from the particles array\n            let currentParticle = particles[ithParticle];\n\n            //now create the postion of the particle on the grid based off of the particles position\n            let particleOnGrid = this._gridPos(currentParticle.position);\n            \n            //push this particle into the grid array using our converter function to convert grid position to index\n            this.grid[this._gridIndex(particleOnGrid)].push(currentParticle);\n\n            //Now we want to set the position key in our spatial hash\n            this.spatialHash[particleOnGrid].push(currentParticle)\n        }\n\n\n    }\n\n    //find particles that are within the bounding box whose dimensions are bound by the support radius of the particle\n    findNearestNeighbors(particle){\n        //first we get the bounding box boundaries\n        const boundingBoxMins = this._gridPos([particle.position[0] - this.s, particle.position[1] - this.s]);\n        const boundingBoxMaxs = this._gridPos([particle.position[0] + this.s, particle.position[1] + this.s]);\n\n        //introduce the clamp function again to filter bounding box range to be inside our grid if on the outside\n        function clamp(num, min, max) {\n            return num <= min ? min : num >= max ? max : num;\n        }\n\n        const bbXmax = clamp(boundingBoxMaxs[0], 0, this.cellY-1);\n        const bbXmin = clamp(boundingBoxMins[0], 0, this.cellY-1);\n        const bbYmin = clamp(boundingBoxMins[1], 0, this.cellY-1);\n        const bbYmax = clamp(boundingBoxMaxs[1], 0, this.cellY-1);\n\n        //this will be the array that will store our neighbors within the support radius\n        let neighbors = [];\n\n        const cells = Object.keys(this.spatialHash);\n\n        //check to see if cell is within the bounds of the bounding box, and if it is then \n        //concat the values into the array\n        cells.forEach((cell) => {\n            if ((parseInt(cell[0]) >= bbXmin && parseInt(cell[0]) <= bbXmax) && (parseInt(cell[2]) >= bbYmin && parseInt(cell[2]) <= bbYmax)){\n                neighbors = neighbors.concat(this.spatialHash[cell])\n            }\n        })\n\n        //use this function to filter out particle we are finding neighbors for, since we added it to our neighbors array\n        function particleFilter(value){\n            return value.position !== particle.position\n        }\n\n        //return the nearest neighbors\n        return neighbors.filter(particleFilter);\n        \n    }\n\n}\n\nexport default SpatialHash;"],"sourceRoot":""}